library(RPostgres)
library(ggplot2)
library(ade4)
library(vegan)
library(gclus)
library(cluster)
library(FD)
library(functional)
library(ggdendro)
library(dendextend)
library(colorspace)
library(labdsv)
library(stats)
library(indicspecies)
library(fpc)
library(goeveg)
library(reshape)
library(e1071)
library(caret)
library(vegan3d)
library(dplyr)
library(optpart)

setwd("G:/NaturalResources/Reinier/Documents/Documents/R_work/projects/pcap_analysis")

source("coldiss.R")

## db connectin set using code in db_connection script ##

# query table with relative cover for non-tree species and IV for tree species
# pcap.combined <- dbGetQuery(conn, "SELECT a.plot_id, a.species, b.acronym, a.relative_cover AS abundance FROM vibi.alt_herbaceous_relative_cover a LEFT JOIN vibi.species b ON a.species = b.scientific_name WHERE a.species NOT LIKE '%sp.%' AND b.form <> 'tree' AND a.plot_id LIKE '%_1st%' AND a.plot_id NOT LIKE '%3440%' AND a.plot_id NOT LIKE '%3405%' 
# UNION 
# SELECT a.plot_id, a.species, b.acronym || '_1' as acronym, a.iv AS abundance FROM nr_misc.alt_reduced_fds2_iv_small a LEFT JOIN vibi.species b ON a.species = b.scientific_name WHERE a.species NOT LIKE '%sp.%' AND b.form = 'tree' AND a.plot_id LIKE '%_1st%' AND a.plot_id NOT LIKE '%3440%' AND a.plot_id NOT LIKE '%3405%' 
# UNION 
# SELECT a.plot_id, a.species, b.acronym || '_2' as acronym, a.iv AS abundance FROM nr_misc.alt_reduced_fds2_iv_big a LEFT JOIN vibi.species b ON a.species = b.scientific_name WHERE a.species NOT LIKE '%sp.%' AND b.form = 'tree' AND a.plot_id LIKE '%_1st%' AND a.plot_id NOT LIKE '%3440%' AND a.plot_id NOT LIKE '%3405%';")

# same as above but includes wetland program plots
vibi.combined <- dbGetQuery(conn, "SELECT * FROM nr_misc.plot_data_for_veg_comm_analysis;")

# reshape pcap.combined into site X species matrix
# pcap.combined.matrix <- cast(pcap.combined, plot_id ~ acronym, value='abundance', fun="mean")

# reshape vibi.combined into site X species matrix
vibi.combined.matrix <- cast(vibi.combined, plot_id ~ acronym, value='abundance', fun="mean")


#examine pcap.combined.matrix table
# pcap.combined.matrix
#edit(pcap.combined.matrix)
#str(pcap.combined.matrix, list.len = 999)
#names(pcap.combined.matrix)
# row.names(pcap.combined.matrix) <- pcap.combined.matrix[ ,1]
# nrow(pcap.combined.matrix)
# ncol(pcap.combined.matrix)


#examine vibi.combined.matrix table
#vibi.combined.matrix
#edit(vibi.combined.matrix)
#str(vibi.combined.matrix, list.len = 999)
## set row names
row.names(vibi.combined.matrix) <- vibi.combined.matrix[ ,1]
names(vibi.combined.matrix)
nrow(vibi.combined.matrix)
ncol(vibi.combined.matrix)

##change NAs to 0
# pcap.combined.matrix[is.na(pcap.combined.matrix)] <- 0
vibi.combined.matrix[is.na(vibi.combined.matrix)] <- 0

# #scale abundances by dividing them by the maximum value for each species
# #Note: MARGIN-2 (default value) for this method
# pcap.combined.scale <- decostand(pcap.combined.matrix, "max")
vibi.combined.scale <- decostand(vibi.combined.matrix, "max")

# # Scale abundances by dividing the by the species totals (relative abundance per species)
# #Note: MARGIN=2 for this method
# pcap.combined.relsp <- decostand(pcap.combined.matrix, "total", MARGIN=2)
vibi.combined.relsp <- decostand(vibi.combined.matrix, "total", MARGIN=2)

##Site profiles: 3 methods; presence-absence or abundance data
#****************************************************************

# #Scale abundances by dividing them by the site totals (relative abundances or relative frequencies, per site)
# #Note: MARGIN=1 (default value) for this method
# pcap.combined.rel <- decostand(pcap.combined.matrix, "total")  #default MARGIN=1
vibi.combined.rel <- decostand(vibi.combined.matrix, "total")  #default MARGIN=1

# #Give a length of 1 to each row vector (EUclidian norm)
# pcap.combined.norm <- decostand(pcap.combined.matrix, "normalize")
vibi.combined.norm <- decostand(vibi.combined.matrix, "normalize")

# #The scaling above is called the 'chord transformation': the Euclidian distance
# #function applied to chord transformed data produces a chord distance matrix
# #(Chapter 3).  Useful before PCA and RDA (Chpaters 5 and 6) and K-means
# #partitioning (Chapter 4)


##Hellinger standardization and euclidean distance matrix
# pcap.combined.hell <- decostand(pcap.combined.matrix, "hel", margin = 1)
# pcap.combined.hell.dist <- vegdist(pcap.combined.hell, "euc")
# head(pcap.combined.hell.dist)

vibi.combined.hell <- decostand(vibi.combined.matrix, "hel", margin = 1)
vibi.combined.hell.dist <- vegdist(vibi.combined.hell, "euc")
head(vibi.combined.hell.dist)

# ##This (above) is called the Hellinger transformation.  THe Euclidian distance
# #function applied to Hellinger-transformed data produces a Hellinger distance
# #matrix (Chapter 3).  Useful before PCA and RDA (Chpaters 5 and 6) and K-means
# #partitioning (Chapter 4).
# #Note: the Hellinger transformation can also be obtained by applying the 
# #chord transformation to square root transformed species data


# #Standardization of both species and sites (double profiles)
# #******************************************************************
# 
# #Chi-square transformation
# pcap.combined.chi <- decostand(pcap.combined.matrix, "chi.square")
vibi.combined.chi <- decostand(vibi.combined.matrix, "chi.square")

# #The Euclidian distance function applied to chi-square-transformed data produces a chi-square distance matirx

#Wisconsin standardization: abundances are first ranged by species maxima and then by site totals
# pcap.combined.wis <- wisconsin(pcap.combined.matrix)
vibi.combined.wis <- wisconsin(vibi.combined.matrix)


##set row names to plot numbers in column 1
# row.names(pcap.combined.wis) <- pcap.combined.wis[ ,1]
# row.names(pcap.combined.wis) #check to see if row names are correct

row.names(vibi.combined.wis) <- vibi.combined.wis[ ,1]
row.names(vibi.combined.wis) #check to see if row names are correct


# ##bray-curtis dissimilarity matrix 
# pcap.combined.bray <- vegdist(pcap.combined.matrix)
vibi.combined.bray <- vegdist(vibi.combined.wis)

# 
# ##bray-curtis on log-transformed data
# ?log1p
# pcap.combined.bray.log <- vegdist(log1p(pcap.combined.matrix[, -1]))
vibi.combined.bray.log <- vegdist(log1p(vibi.combined.wis[, -1]))

# ##bray-curtis on sqrt-transformed data
# pcap.combined.bray.sqrt <- vegdist(sqrt(pcap.combined.matrix[, -1]))
vibi.combined.bray.sqrt <- vegdist(sqrt(vibi.combined.wis[, -1]))

# ##bray-curtis on wisconsin-standardized data





# ##Boxplots of transformed abundances of common species
# #************************************************************
# 
# #Find and replace to quickly view plots for different species
# Acer rubrum
#par(mfrow=c(2,2))

boxplot(vibi.combined.matrix$ACERUB_2, sqrt(vibi.combined.matrix$ACERUB_2), log1p(vibi.combined.matrix$ACERUB_2),
        las=1, main = "Simple Transformation",
        names=c("raw data", "sqrt", "log"), col="bisque")

boxplot(vibi.combined.scale$ACERUB_2, vibi.combined.relsp$ACERUB_2, las=1, main="Standardization by Species",
        names=c("max", "total"), col="lightgreen")

boxplot(vibi.combined.hell$ACERUB_2, vibi.combined.rel$ACERUB_2, vibi.combined.norm$ACERUB_2,
        las=1, main="Standardization by Sites",
        names=c("Hellinger", "total", "norm"), col="lightblue")

boxplot(vibi.combined.chi$ACERUB_2, vibi.combined.wis$ACERUB_2, las=1, main="Double Standardization",
        names=c("Chi-square", "Wisconsin"), col="orange")

#dev.off()

# Acer saccharum (pole timber diameter and smaller)
#par(mfrow=c(2,2))

boxplot(vibi.combined.matrix$ACESAR_1, sqrt(vibi.combined.matrix$ACESAR_1), log1p(vibi.combined.matrix$ACESAR_1),
        las=1, main = "Simple Transformation",
        names=c("raw data", "sqrt", "log"), col="bisque")

boxplot(vibi.combined.scale$ACESAR_1, vibi.combined.relsp$ACESAR_1, las=1, main="Standardization by Species",
        names=c("max", "total"), col="lightgreen")

boxplot(vibi.combined.hell$ACESAR_1, vibi.combined.rel$ACESAR_1, vibi.combined.norm$ACESAR_1,
        las=1, main="Standardization by Sites",
        names=c("Hellinger", "total", "norm"), col="lightblue")

boxplot(vibi.combined.chi$ACESAR_1, vibi.combined.wis$ACESAR_1, las=1, main="Double Standardization",
        names=c("Chi-square", "Wisconsin"), col="orange")

#dev.off()


# Acer saccharum (>25 cm dbh)
#par(mfrow=c(2,2))

boxplot(vibi.combined.matrix$ACESAR_2, sqrt(vibi.combined.matrix$ACESAR_2), log1p(vibi.combined.matrix$ACESAR_2),
        las=1, main = "Simple Transformation",
        names=c("raw data", "sqrt", "log"), col="bisque")

boxplot(vibi.combined.scale$ACESAR_2, vibi.combined.relsp$ACESAR_2, las=1, main="Standardization by Species",
        names=c("max", "total"), col="lightgreen")

boxplot(vibi.combined.hell$ACESAR_2, vibi.combined.rel$ACESAR_2, vibi.combined.norm$ACESAR_2,
        las=1, main="Standardization by Sites",
        names=c("Hellinger", "total", "norm"), col="lightblue")

boxplot(vibi.combined.chi$ACESAR_2, vibi.combined.wis$ACESAR_2, las=1, main="Double Standardization",
        names=c("Chi-square", "Wisconsin"), col="orange")

#dev.off()

# Fagus grandifolia (pole timber and smaller)
#par(mfrow=c(2,2))

boxplot(vibi.combined.matrix$FAGGRA_1, sqrt(vibi.combined.matrix$FAGGRA_1), log1p(vibi.combined.matrix$FAGGRA_1),
        las=1, main = "Simple Transformation",
        names=c("raw data", "sqrt", "log"), col="bisque")

boxplot(vibi.combined.scale$FAGGRA_1, vibi.combined.relsp$FAGGRA_1, las=1, main="Standardization by Species",
        names=c("max", "total"), col="lightgreen")

boxplot(vibi.combined.hell$FAGGRA_1, vibi.combined.rel$FAGGRA_1, vibi.combined.norm$FAGGRA_1,
        las=1, main="Standardization by Sites",
        names=c("Hellinger", "total", "norm"), col="lightblue")

boxplot(vibi.combined.chi$FAGGRA_1, vibi.combined.wis$FAGGRA_1, las=1, main="Double Standardization",
        names=c("Chi-square", "Wisconsin"), col="orange")

#dev.off()


# Fagus grandifolia (>25cm dbh)
#par(mfrow=c(2,2))

boxplot(vibi.combined.matrix$FAGGRA_2, sqrt(vibi.combined.matrix$FAGGRA_2), log1p(vibi.combined.matrix$FAGGRA_2),
        las=1, main = "Simple Transformation",
        names=c("raw data", "sqrt", "log"), col="bisque")

boxplot(vibi.combined.scale$FAGGRA_2, vibi.combined.relsp$FAGGRA_2, las=1, main="Standardization by Species",
        names=c("max", "total"), col="lightgreen")

boxplot(vibi.combined.hell$FAGGRA_2, vibi.combined.rel$FAGGRA_2, vibi.combined.norm$FAGGRA_2,
        las=1, main="Standardization by Sites",
        names=c("Hellinger", "total", "norm"), col="lightblue")

boxplot(vibi.combined.chi$FAGGRA_2, vibi.combined.wis$FAGGRA_2, las=1, main="Double Standardization",
        names=c("Chi-square", "Wisconsin"), col="orange")

#dev.off()


# Quercus rubra (pole timber and smaller)
#par(mfrow=c(2,2))

boxplot(vibi.combined.matrix$QUERUB_1, sqrt(vibi.combined.matrix$QUERUB_1), log1p(vibi.combined.matrix$QUERUB_1),
        las=1, main = "Simple Transformation",
        names=c("raw data", "sqrt", "log"), col="bisque")

boxplot(vibi.combined.scale$QUERUB_1, vibi.combined.relsp$QUERUB_1, las=1, main="Standardization by Species",
        names=c("max", "total"), col="lightgreen")

boxplot(vibi.combined.hell$QUERUB_1, vibi.combined.rel$QUERUB_1, vibi.combined.norm$QUERUB_1,
        las=1, main="Standardization by Sites",
        names=c("Hellinger", "total", "norm"), col="lightblue")

boxplot(vibi.combined.chi$QUERUB_1, vibi.combined.wis$QUERUB_1, las=1, main="Double Standardization",
        names=c("Chi-square", "Wisconsin"), col="orange")

#dev.off()


# Quercus rubra (>25cm dbh)
#par(mfrow=c(2,2))

boxplot(vibi.combined.matrix$QUERUB_2, sqrt(vibi.combined.matrix$QUERUB_2), log1p(vibi.combined.matrix$QUERUB_2),
        las=1, main = "Simple Transformation",
        names=c("raw data", "sqrt", "log"), col="bisque")

boxplot(vibi.combined.scale$QUERUB_2, vibi.combined.relsp$QUERUB_2, las=1, main="Standardization by Species",
        names=c("max", "total"), col="lightgreen")

boxplot(vibi.combined.hell$QUERUB_2, vibi.combined.rel$QUERUB_2, vibi.combined.norm$QUERUB_2,
        las=1, main="Standardization by Sites",
        names=c("Hellinger", "total", "norm"), col="lightblue")

boxplot(vibi.combined.chi$QUERUB_2, vibi.combined.wis$QUERUB_2, las=1, main="Double Standardization",
        names=c("Chi-square", "Wisconsin"), col="orange")

#dev.off()


# Verbesina alternifolia
#par(mfrow=c(2,2))

boxplot(vibi.combined.matrix$VERALT, sqrt(vibi.combined.matrix$VERALT), log1p(vibi.combined.matrix$VERALT),
        las=1, main = "Simple Transformation",
        names=c("raw data", "sqrt", "log"), col="bisque")

boxplot(vibi.combined.scale$VERALT, vibi.combined.relsp$VERALT, las=1, main="Standardization by Species",
        names=c("max", "total"), col="lightgreen")

boxplot(vibi.combined.hell$VERALT, vibi.combined.rel$VERALT, vibi.combined.norm$VERALT,
        las=1, main="Standardization by Sites",
        names=c("Hellinger", "total", "norm"), col="lightblue")

boxplot(vibi.combined.chi$VERALT, vibi.combined.wis$VERALT, las=1, main="Double Standardization",
        names=c("Chi-square", "Wisconsin"), col="orange")

#dev.off()


##Ward's minimum variance clustering using Hellinger distance matrix
# pcap.combined.clust.ward.hell <- hclust(pcap.combined.hell.dist, method = "ward.D")
# plot(pcap.combined.clust.ward.hell)

vibi.combined.clust.ward.hell <- hclust(vibi.combined.hell.dist, method = "ward.D")
plot(vibi.combined.clust.ward.hell)

##just for comparison try Ward's clustering using bray-curtis
# pcap.combined.clust.ward.sqrt <- hclust(pcap.combined.bray.sqrt, method = "ward.D")
# plot(pcap.combined.clust.ward.sqrt)

# vibi.combined.clust.ward.sqrt <- hclust(vibi.combined.bray.sqrt, method = "ward.D")
# plot(vibi.combined.clust.ward.sqrt)

# # Examine the dendrogram(s). How many groups does it contain?
# # Create a vector 'groups' showing the group to which each site belongs,
# # in the original order of entry of the sites.
# pcap.combined.cl.groups = cutree(pcap.combined.clust.ward.hell, k=5)
#pcap.combined.cl.groups


## cluster using double standardized matrix, bray-curtis dissimilarity and flexible beta clustering
# vibi.combined.clust.bray.flex <- agnes(vibi.combined.bray, diss=TRUE, par.method=1)
# plot(vibi.combined.clust.bray.flex)

# Optimal number of clusters according to silhouette widths
# (Rousseeuw quality index)
# *********************************************************

# Plot average silhouette widths (using Ward clustering) for all partitions 
# except for the trivial partition in a single group (k=1)
# First, create an empty vector in which the average silhouette width (asw) values will be written
# k <- 6
# asw <- numeric(nrow(vibi.combined.matrix))
# # Second, retrieve the asw values and write them into the vector
# for (k in 2:(nrow(vibi.combined.matrix)-1)) {
#   sil <- silhouette(cutree(vibi.combined.clust.ward.hell, k=k), vibi.combined.hell.dist)
#   asw[k] <- summary(sil)$avg.width
# }
# k.best <- which.max(asw)
# dev.new(title="Silhouettes - Ward - k = 2 to n-1")
# plot(1:nrow(vibi.combined.matrix), asw, type="h", 
#      main="Silhouette-optimal number of clusters, Ward", 
#      xlab="k (number of groups)", ylab="Average silhouette width")
# axis(1, k.best, paste("optimum",k.best,sep="\n"), col="red", font=2,
#      col.axis="red")
# points(k.best, max(asw), pch=16, col="red", cex=1.5)
# cat("", "Silhouette-optimal number of clusters k =", k.best, "\n", 
#     "with an average silhouette width of", max(asw), "\n")


vibi.combined.cl.groups = cutree(vibi.combined.clust.ward.hell, k=6)
#vibi.combined.cl.groups

# Silhouette plot of the final partition
# **************************************

# Choose the number of clusters
# k <- 6
# # Silhouette plot
# cutg <- cutree(vibi.combined.clust.ward.hell, k=k)
# sil <- silhouette(cutg, vibi.combined.hell.dist)
# rownames(sil) <- row.names(vibi.combined.matrix)
# dev.new(title="Silhouette plot - Ward - k=6")
# plot(sil, main="Silhouette plot - Hellinger - Ward", 
#      cex.names=0.8, col=2:(k+1), nmax=100)


# Final dendrogram with the selected groups
# *****************************************

#reorder dendrogram
# pcap.combined.ward.reorder <- reorder.hclust(pcap.combined.clust.ward.hell, pcap.combined.hell.dist)

vibi.combined.ward.reorder <- reorder.hclust(vibi.combined.clust.ward.hell, vibi.combined.hell.dist)

# Plot reordered dendrogram with group labels
dev.new(title="Final dendrogram", width=8, height=6)
plot(vibi.combined.ward.reorder, hang=-1, xlab="8 groups", sub="", 
     ylab="Height", main="Hellinger - Ward (reordered)", 
     labels=cutree(vibi.combined.ward.reorder, k=6))
rect.hclust(vibi.combined.ward.reorder, k=6)

source("hcoplot.R")
# hcoplot(pcap.combined.clust.ward.hell, pcap.combined.hell.dist, k=5)
# dev.new()
hcoplot(vibi.combined.clust.ward.hell, vibi.combined.hell.dist, k=6)

## customize final dendrogram with dendextend
dend.vibi <- as.dendrogram(vibi.combined.ward.reorder, hang=-8)

# Get various attributes (just an example)
#dend.pcap.forests %>% get_nodes_attr("height")

# work on drawing rectangles around clusters
dev.new()
dend.vibi %>% plot(leaflab = "none") 
text(40,-0.6, "Alluvial (Ruderal) Forest and Woodland", cex=0.85, font=4, xpd=NA);
text(118,-0.6, "Mesic/Wet-Mesic (Ruderal) Meadow", cex=0.85, font=4);
text(185,-0.6, "Wet-Mesic Early Successional 
     Forest/Shrub", cex=0.85, font=4, xpd=NA);
text(234,-0.6, "Tuliptree-
     Mixed Hardwood", cex=0.85, font=4, xpd=NA)
text(267,-0.6, "Wet-Mesic 
     Red Maple Forest", cex=0.85, font=4)
text(315,-0.6, "Oak-Mixed Hardwood Forest", cex=0.85, font=4)
text(360,-0.6, "Beech (Hemlock)-
     Mixed Hardwood", cex=0.85, font=4)
text(422,-0.6, "Sugar Maple-Mixed Hardwood Forest", cex=0.85, font=4);
#need to keep building this

dend.vibi %>% rect.dendrogram(k=8, border = 1, lty = 2, lwd = 3, lower_rect = -2)


# ##try some indicator species analysis##
# 
# #first using IndVal function#

# Look for the indicator species in ward clustering
# pcap.combined.indval.out = indval(pcap.combined.matrix[,-1], pcap.combined.cl.groups, numitr=10000)
# remove plot_id and PYRBAC column
vibi.combined.indval.out = indval(vibi.combined.matrix[,c(-1,-630)], vibi.combined.cl.groups, numitr=10000)

# Table of the significant indicator species
# gr <- pcap.combined.indval.out$maxcls[pcap.combined.indval.out$pval <= 0.05]
# iv <- pcap.combined.indval.out$indcls[pcap.combined.indval.out$pval <= 0.05]
# pv <- pcap.combined.indval.out$pval[pcap.combined.indval.out$pval <= 0.05]
# fr <- apply(pcap.combined.matrix[,2:707] > 0, 2, sum)[pcap.combined.indval.out$pval <= 0.05]
# fidg <- data.frame(group=gr, indval=iv, pvalue=pv, freq=fr)
# fidg <- fidg[order(fidg$group, -fidg$indval),]
# fidg

vibi.gr <- vibi.combined.indval.out$maxcls[vibi.combined.indval.out$pval <= 0.05]
vibi.iv <- vibi.combined.indval.out$indcls[vibi.combined.indval.out$pval <= 0.05]
vibi.pv <- vibi.combined.indval.out$pval[vibi.combined.indval.out$pval <= 0.05]
vibi.fr <- apply(vibi.combined.matrix[,c(-1,-630)] > 0, 2, sum)[vibi.combined.indval.out$pval <= 0.05]
vibi.fidg <- data.frame(group=vibi.gr, indval=vibi.iv, pvalue=vibi.pv, freq=vibi.fr)
vibi.fidg <- vibi.fidg[order(vibi.fidg$group, -vibi.fidg$indval),]
vibi.fidg
write.csv(vibi.fidg, file="vibi_indval_results_02132022.csv")


#merge for subsequent analyses
vibi.combined.cl.groups <- as.data.frame(vibi.combined.cl.groups)
vibi.combined.class <- merge(vibi.combined.matrix, vibi.combined.cl.groups, by="row.names")
row.names(vibi.combined.class) <- vibi.combined.class[,1]
vibi.combined.class <- vibi.combined.class[, -c(1:2)]
rownames(vibi.combined.class)
colnames(vibi.combined.class)


#write group assignemnt to csv to merge with data table for addtional analyses
write.csv(vibi.combined.class, file="hell_ward_cluster_assignments_pcap_combined_02132022.csv")


##try some other clustering methods

##try k-means clustering
# With 6 groups
vibi.combined.kmeans <- kmeans(vibi.combined.hell, centers=6, nstart=100)
summary(vibi.combined.kmeans)
vibi.combined.kmeans$cluster

##run indicator species analysis on k-means clusters
vibi.combined.kmeans.indval.out = indval(vibi.combined.matrix[,c(-1,-630)], vibi.combined.kmeans$cluster, numitr=10000)

vibi.kmeans.gr <- vibi.combined.kmeans.indval.out$maxcls[vibi.combined.kmeans.indval.out$pval <= 0.05]
vibi.kmeans.iv <- vibi.combined.kmeans.indval.out$indcls[vibi.combined.kmeans.indval.out$pval <= 0.05]
vibi.kmeans.pv <- vibi.combined.kmeans.indval.out$pval[vibi.combined.kmeans.indval.out$pval <= 0.05]
vibi.kmeans.fr <- apply(vibi.combined.matrix[,c(-1,-630)] > 0, 2, sum)[vibi.combined.kmeans.indval.out$pval <= 0.05]
vibi.kmeans.fidg <- data.frame(group=vibi.kmeans.gr, indval=vibi.kmeans.iv, pvalue=vibi.kmeans.pv, freq=vibi.kmeans.fr)
vibi.kmeans.fidg <- vibi.kmeans.fidg[order(vibi.kmeans.fidg$group, -vibi.kmeans.fidg$indval),]
vibi.kmeans.fidg
write.csv(vibi.kmeans.fidg, file="vibi_indval_kmeans_results_02162022.csv")

##combine k-means clusters with plot matrix
kmeans_cluster <- vibi.combined.kmeans$cluster
vibi.kmeans.cluster <- cbind(vibi.combined.matrix, kmeans_cluster)
write.csv(vibi.kmeans.cluster, file="vibi_cluster_kmeans_results_02162022.csv")

# With 8 groups
vibi.combined.kmeans8 <- kmeans(vibi.combined.hell, centers=8, nstart=100)
summary(vibi.combined.kmeans8)
vibi.combined.kmeans8$cluster

##run indicator species analysis on k-means clusters with 8 groups
vibi.combined.kmeans8.indval.out = indval(vibi.combined.matrix[,c(-1,-630)], vibi.combined.kmeans8$cluster, numitr=10000)

vibi.kmeans8.gr <- vibi.combined.kmeans8.indval.out$maxcls[vibi.combined.kmeans8.indval.out$pval <= 0.05]
vibi.kmeans8.iv <- vibi.combined.kmeans8.indval.out$indcls[vibi.combined.kmeans8.indval.out$pval <= 0.05]
vibi.kmeans8.pv <- vibi.combined.kmeans8.indval.out$pval[vibi.combined.kmeans8.indval.out$pval <= 0.05]
vibi.kmeans8.fr <- apply(vibi.combined.matrix[,c(-1,-630)] > 0, 2, sum)[vibi.combined.kmeans8.indval.out$pval <= 0.05]
vibi.kmeans8.fidg <- data.frame(group=vibi.kmeans8.gr, indval=vibi.kmeans8.iv, pvalue=vibi.kmeans8.pv, freq=vibi.kmeans8.fr)
vibi.kmeans8.fidg <- vibi.kmeans8.fidg[order(vibi.kmeans8.fidg$group, -vibi.kmeans8.fidg$indval),]
vibi.kmeans8.fidg
write.csv(vibi.kmeans8.fidg, file="vibi_indval_kmeans8_results_02162022.csv")

##combine k-means clusters (8 groups) with plot matrix
kmeans8_cluster <- vibi.combined.kmeans8$cluster
vibi.kmeans8.cluster <- cbind(vibi.combined.matrix, kmeans8_cluster)
write.csv(vibi.kmeans8.cluster, file="vibi_cluster_kmeans8_results_02162022.csv")

##try optpart function on the k-means8 result to "polish"
vibi.combined.kmeans8.optpart <- optpart(kmeans8_cluster, vibi.combined.hell.dist)
summary(vibi.combined.kmeans8.optpart)
vibi.combined.kmeans8.optpart$clustering

##try optsil function on k-means result fromm above
vibi.combined.kmeans8.optsil <- optsil(kmeans8_cluster, vibi.combined.hell.dist)
summary(vibi.combined.kmeans8.optsil)
vibi.combined.kmeans8.optsil$clustering
kmeans8_optsil_clulster <- vibi.combined.kmeans8.optsil$clustering 
vibi.kmeans8.optsil.cluster <- cbind(vibi.combined.matrix, kmeans8_optsil_clulster)
write.csv(vibi.kmeans8.optsil.cluster, file="vibi_cluster_kmeans8_optsil_results_02172022.csv")

##run indicator species analysis on k-means8 + optsil results
vibi.kmeans8.optsil.indval.out = indval(vibi.combined.matrix[,c(-1,-630)], vibi.combined.kmeans8.optsil$clustering, numitr=10000)

vibi.kmeans8.optsil.gr <- vibi.kmeans8.optsil.indval.out$maxcls[vibi.kmeans8.optsil.indval.out$pval <= 0.05]
vibi.kmeans8.optsil.iv <- vibi.kmeans8.optsil.indval.out$indcls[vibi.kmeans8.optsil.indval.out$pval <= 0.05]
vibi.kmeans8.optsil.pv <- vibi.kmeans8.optsil.indval.out$pval[vibi.kmeans8.optsil.indval.out$pval <= 0.05]
vibi.kmeans8.optsil.fr <- apply(vibi.combined.matrix[,c(-1,-630)] > 0, 2, sum)[vibi.kmeans8.optsil.indval.out$pval <= 0.05]
vibi.kmeans8.optsil.fidg <- data.frame(group=vibi.kmeans8.optsil.gr, indval=vibi.kmeans8.optsil.iv, pvalue=vibi.kmeans8.optsil.pv, freq=vibi.kmeans8.optsil.fr)
vibi.kmeans8.optsil.fidg <- vibi.kmeans8.optsil.fidg[order(vibi.kmeans8.optsil.fidg$group, -vibi.kmeans8.optsil.fidg$indval),]
vibi.kmeans8.optsil.fidg
write.csv(vibi.kmeans8.optsil.fidg, file="vibi_indval_kmeans8_optsil_results_02172022.csv")


##run indicator species analysis on optsil clusters
vibi.combined.optsil.indval.out = indval(vibi.combined.matrix[,c(-1,-630)], vibi.combined.cl.optsil$clustering, numitr=10000)

vibi.optsil.gr <- vibi.combined.optsil.indval.out$maxcls[vibi.combined.optsil.indval.out$pval <= 0.05]
vibi.optsil.iv <- vibi.combined.optsil.indval.out$indcls[vibi.combined.optsil.indval.out$pval <= 0.05]
vibi.optsil.pv <- vibi.combined.optsil.indval.out$pval[vibi.combined.optsil.indval.out$pval <= 0.05]
vibi.optsil.fr <- apply(vibi.combined.matrix[,c(-1,-630)] > 0, 2, sum)[vibi.combined.optsil.indval.out$pval <= 0.05]
vibi.optsil.fidg <- data.frame(group=vibi.optsil.gr, indval=vibi.optsil.iv, pvalue=vibi.optsil.pv, freq=vibi.optsil.fr)
vibi.optsil.fidg <- vibi.optsil.fidg[order(vibi.optsil.fidg$group, -vibi.optsil.fidg$indval),]
vibi.optsil.fidg
write.csv(vibi.optsil.fidg, file="vibi_indval_optsil_results_02142022.csv")

#try optindval function in optpart package
vibi.combined.optindval <- optindval(vibi.combined.matrix[,c(-1,-630)], vibi.combined.cl.groups$vibi.combined.cl.groups)
optindval.cluster <- vibi.combined.optindval$clustering
vibi.optindval.cluster <- cbind(vibi.combined.matrix, optindval.cluster)
#colnames(vibi.optsil.cluster) <- c("plot_id", "optsil_cluster")
ncol(vibi.optindval.cluster)
write.csv(vibi.optindval.cluster, file="vibi_cluster_optindval_results_02142022.csv", row.names = FALSE)



#merge optsil for subsequent analyses
optsil.cluster <- vibi.combined.cl.optsil$clustering
vibi.optsil.cluster <- cbind(vibi.combined.matrix, optsil.cluster)
#colnames(vibi.optsil.cluster) <- c("plot_id", "optsil_cluster")
ncol(vibi.optsil.cluster)
write.csv(vibi.optsil.cluster, file="vibi_cluster_optsil_results_02142022.csv", row.names = FALSE)

##try optdev function
# vibi.combined.cl.opttdev <- opttdev(vibi.combined.matrix, vibi.combined.cl.groups$vibi.combined.cl.groups)
# summary(vibi.combined.cl.opttdev)
# vibi.combined.cl.opttdev$clustering

##try "refine" function from optpart package to reassign problematic plots
##doesn't seem to like data.frame source
# vibi.combined.df <- as.data.frame(vibi.combined.matrix)
# vibi.optsil.cluster.refine <- refine(vibi.combined.df$plot_id, vibi.combined.cl.opttdev$clustering)


########  Community analysis on most recent sample #########


# same as above but includes wetland program plots
vibi.combined.new <- dbGetQuery(conn, "SELECT * FROM nr_misc.plot_data_for_veg_comm_analysis_newest_sample;")

# reshape pcap.combined into site X species matrix
# pcap.combined.matrix <- cast(pcap.combined, plot_id ~ acronym, value='abundance', fun="mean")

# reshape vibi.combined into site X species matrix
vibi.combined.matrix.new <- cast(vibi.combined.new, plot_id ~ acronym, value='abundance', fun="mean")


## set row names
row.names(vibi.combined.matrix.new) <- vibi.combined.matrix.new[ ,1]
names(vibi.combined.matrix.new)
nrow(vibi.combined.matrix.new)
ncol(vibi.combined.matrix.new)

##change NAs to 0
# pcap.combined.matrix[is.na(pcap.combined.matrix)] <- 0
vibi.combined.matrix.new[is.na(vibi.combined.matrix.new)] <- 0

# #scale abundances by dividing them by the maximum value for each species
# #Note: MARGIN-2 (default value) for this method
vibi.combined.new.scale <- decostand(vibi.combined.matrix.new, "max")

# # Scale abundances by dividing the by the species totals (relative abundance per species)
# #Note: MARGIN=2 for this method
vibi.combined.new.relsp <- decostand(vibi.combined.matrix.new, "total", MARGIN=2)

##Site profiles: 3 methods; presence-absence or abundance data
#****************************************************************

# #Scale abundances by dividing them by the site totals (relative abundances or relative frequencies, per site)
# #Note: MARGIN=1 (default value) for this method
vibi.combined.new.rel <- decostand(vibi.combined.matrix.new, "total")  #default MARGIN=1

# #Give a length of 1 to each row vector (EUclidian norm)
vibi.combined.new.norm <- decostand(vibi.combined.matrix.new, "normalize")

# #The scaling above is called the 'chord transformation': the Euclidian distance
# #function applied to chord transformed data produces a chord distance matrix
# #(Chapter 3).  Useful before PCA and RDA (Chpaters 5 and 6) and K-means
# #partitioning (Chapter 4)


##Hellinger standardization and euclidean distance matrix
# pcap.combined.hell <- decostand(pcap.combined.matrix, "hel", margin = 1)
# pcap.combined.hell.dist <- vegdist(pcap.combined.hell, "euc")
# head(pcap.combined.hell.dist)

vibi.combined.new.hell <- decostand(vibi.combined.matrix.new, "hel", margin = 1)
vibi.combined.new.hell.dist <- vegdist(vibi.combined.new.hell, "euc")
head(vibi.combined.new.hell.dist)

# ##This (above) is called the Hellinger transformation.  THe Euclidian distance
# #function applied to Hellinger-transformed data produces a Hellinger distance
# #matrix (Chapter 3).  Useful before PCA and RDA (Chpaters 5 and 6) and K-means
# #partitioning (Chapter 4).
# #Note: the Hellinger transformation can also be obtained by applying the 
# #chord transformation to square root transformed species data


# #Standardization of both species and sites (double profiles)
# #******************************************************************
# 
# #Chi-square transformation
# pcap.combined.chi <- decostand(pcap.combined.matrix, "chi.square")
vibi.combined.new.chi <- decostand(vibi.combined.matrix.new, "chi.square")

# #The Euclidian distance function applied to chi-square-transformed data produces a chi-square distance matirx

#Wisconsin standardization: abundances are first ranged by species maxima and then by site totals
# pcap.combined.wis <- wisconsin(pcap.combined.matrix)
vibi.combined.new.wis <- wisconsin(vibi.combined.matrix.new)


##set row names to plot numbers in column 1
# row.names(pcap.combined.wis) <- pcap.combined.wis[ ,1]
# row.names(pcap.combined.wis) #check to see if row names are correct

row.names(vibi.combined.new.wis) <- vibi.combined.new.wis[ ,1]
row.names(vibi.combined.new.wis) #check to see if row names are correct


# ##bray-curtis dissimilarity matrix 
# pcap.combined.bray <- vegdist(pcap.combined.matrix)
vibi.combined.new.bray <- vegdist(vibi.combined.new.wis)

# 
# ##bray-curtis on log-transformed data
# ?log1p
# pcap.combined.bray.log <- vegdist(log1p(pcap.combined.matrix[, -1]))
vibi.combined.new.bray.log <- vegdist(log1p(vibi.combined.new.wis[, -1]))

# ##bray-curtis on sqrt-transformed data
# pcap.combined.bray.sqrt <- vegdist(sqrt(pcap.combined.matrix[, -1]))
vibi.combined.new.bray.sqrt <- vegdist(sqrt(vibi.combined.new.wis[, -1]))

# ##bray-curtis on wisconsin-standardized data


##try some other clustering methods

##try k-means clustering
# With 7 groups
vibi.combined.new.kmeans7 <- kmeans(vibi.combined.new.hell, centers=7, nstart=100)
summary(vibi.combined.new.kmeans7)
vibi.combined.new.kmeans7$cluster

##run indicator species analysis on k-means clusters with 7 groups
vibi.combined.new.kmeans7.indval.out = indval(vibi.combined.matrix.new[,c(-1,-647)], vibi.combined.new.kmeans7$cluster, numitr=10000)

vibi.new.kmeans7.gr <- vibi.combined.new.kmeans7.indval.out$maxcls[vibi.combined.new.kmeans7.indval.out$pval <= 0.05]
vibi.new.kmeans7.iv <- vibi.combined.new.kmeans7.indval.out$indcls[vibi.combined.new.kmeans7.indval.out$pval <= 0.05]
vibi.new.kmeans7.pv <- vibi.combined.new.kmeans7.indval.out$pval[vibi.combined.new.kmeans7.indval.out$pval <= 0.05]
vibi.new.kmeans7.fr <- apply(vibi.combined.matrix.new[,c(-1,-647)] > 0, 2, sum)[vibi.combined.new.kmeans7.indval.out$pval <= 0.05]
vibi.new.kmeans7.fidg <- data.frame(group=vibi.new.kmeans7.gr, indval=vibi.new.kmeans7.iv, pvalue=vibi.new.kmeans7.pv, freq=vibi.new.kmeans7.fr)
vibi.new.kmeans7.fidg <- vibi.new.kmeans7.fidg[order(vibi.new.kmeans7.fidg$group, -vibi.new.kmeans7.fidg$indval),]
vibi.new.kmeans7.fidg
write.csv(vibi.new.kmeans7.fidg, file="vibi_new_indval_kmeans7_results_07222022.csv")

##combine k-means clusters (7 groups) with plot matrix
kmeans7_cluster <- vibi.combined.new.kmeans7$cluster
vibi.new.kmeans7.cluster <- cbind(vibi.combined.matrix.new, kmeans7_cluster)
write.csv(vibi.new.kmeans7.cluster, file="vibi_new_cluster_kmeans7_results_04182022.csv")

##try optpart function on the kmeans7 result to "polish"
# vibi.combined.kmeans7.optpart <- optpart(kmeans7_cluster, vibi.combined.hell.dist)
# summary(vibi.combined.kmeans7.optpart)
# vibi.combined.kmeans7.optpart$clustering

##try optsil function on k-means result fromm above
vibi.combined.new.kmeans7.optsil <- optsil(kmeans7_cluster, vibi.combined.new.hell.dist)
summary(vibi.combined.new.kmeans7.optsil)
vibi.combined.new.kmeans7.optsil$clustering
kmeans7_optsil_cluster <- vibi.combined.new.kmeans7.optsil$clustering 
vibi.new.kmeans7.optsil.cluster <- cbind(vibi.combined.matrix.new, kmeans7_optsil_cluster)
write.csv(vibi.new.kmeans7.optsil.cluster, file="vibi_new_cluster_kmeans7_optsil_results_04182022.csv")

##run indicator species analysis on kmeans7 + optsil results
vibi.new.kmeans7.optsil.indval.out = indval(vibi.combined.matrix.new[,c(-1,-654)], vibi.combined.new.kmeans7.optsil$clustering, numitr=10000)

vibi.new.kmeans7.optsil.gr <- vibi.new.kmeans7.optsil.indval.out$maxcls[vibi.new.kmeans7.optsil.indval.out$pval <= 0.05]
vibi.new.kmeans7.optsil.iv <- vibi.new.kmeans7.optsil.indval.out$indcls[vibi.new.kmeans7.optsil.indval.out$pval <= 0.05]
vibi.new.kmeans7.optsil.pv <- vibi.new.kmeans7.optsil.indval.out$pval[vibi.new.kmeans7.optsil.indval.out$pval <= 0.05]
vibi.new.kmeans7.optsil.fr <- apply(vibi.combined.matrix.new[,c(-1,-654)] > 0, 2, sum)[vibi.new.kmeans7.optsil.indval.out$pval <= 0.05]
vibi.new.kmeans7.optsil.fidg <- data.frame(group=vibi.new.kmeans7.optsil.gr, indval=vibi.new.kmeans7.optsil.iv, pvalue=vibi.new.kmeans7.optsil.pv, freq=vibi.new.kmeans7.optsil.fr)
vibi.new.kmeans7.optsil.fidg <- vibi.new.kmeans7.optsil.fidg[order(vibi.new.kmeans7.optsil.fidg$group, -vibi.new.kmeans7.optsil.fidg$indval),]
vibi.new.kmeans7.optsil.fidg
write.csv(vibi.new.kmeans7.optsil.fidg, file="vibi_new_indval_kmeans7_optsil_results_04182022.csv")


###### Run analyses above just on "Ruderal Wet-Mesic Thicket..." type to try and break out subtypes ######

vibi.new.thicket <- dbGetQuery(conn, "SELECT * FROM nr_misc.plot_data_for_veg_comm_analysis_newest_sample
WHERE plot_id IN (SELECT plot_id FROM nr_misc.plot_data_for_upland_vibi_development WHERE group_description = 'Ruderal Wet-Mesic Shrubland and Thicket');")

# reshape vibi.combined into site X species matrix
vibi.matrix.new.thicket <- cast(vibi.new.thicket, plot_id ~ acronym, value='abundance', fun="mean")


## set row names
row.names(vibi.matrix.new.thicket) <- vibi.matrix.new.thicket[ ,1]
names(vibi.matrix.new.thicket)
nrow(vibi.matrix.new.thicket)
ncol(vibi.matrix.new.thicket)

##change NAs to 0
# pcap.combined.matrix[is.na(pcap.combined.matrix)] <- 0
vibi.matrix.new.thicket[is.na(vibi.matrix.new.thicket)] <- 0


##Hellinger standardization and euclidean distance matrix
# pcap.combined.hell <- decostand(pcap.combined.matrix, "hel", margin = 1)
# pcap.combined.hell.dist <- vegdist(pcap.combined.hell, "euc")
# head(pcap.combined.hell.dist)

vibi.matrix.new.thicket.hell <- decostand(vibi.matrix.new.thicket, "hel", margin = 1)
vibi.matrix.new.thicket.hell.dist <- vegdist(vibi.matrix.new.thicket.hell, "euc")
head(vibi.matrix.new.thicket.hell.dist)

# ##This (above) is called the Hellinger transformation.  THe Euclidian distance
# #function applied to Hellinger-transformed data produces a Hellinger distance
# #matrix (Chapter 3).  Useful before PCA and RDA (Chpaters 5 and 6) and K-means
# #partitioning (Chapter 4).
# #Note: the Hellinger transformation can also be obtained by applying the 
# #chord transformation to square root transformed species data


# k-means clustering
vibi.new.thicket.hell.dist.kmeans2 <- kmeans(vibi.matrix.new.thicket.hell, centers=2, nstart=100)
summary(vibi.new.thicket.hell.dist.kmeans2)
vibi.new.thicket.hell.dist.kmeans2$cluster

##run indicator species analysis on k-means clusters
vibi.new.thicket.kmeans2.indval.out = indval(vibi.matrix.new.thicket[,c(-1)], vibi.new.thicket.hell.dist.kmeans2$cluster, numitr=10000)

vibi.new.thicket.kmeans2.gr <- vibi.new.thicket.kmeans2.indval.out$maxcls[vibi.new.thicket.kmeans2.indval.out$pval <= 0.05]
vibi.new.thicket.kmeans2.iv <- vibi.new.thicket.kmeans2.indval.out$indcls[vibi.new.thicket.kmeans2.indval.out$pval <= 0.05]
vibi.new.thicket.kmeans2.pv <- vibi.new.thicket.kmeans2.indval.out$pval[vibi.new.thicket.kmeans2.indval.out$pval <= 0.05]
vibi.new.thicket.kmeans2.fr <- apply(vibi.matrix.new.thicket[,c(-1)] > 0, 2, sum)[vibi.new.thicket.kmeans2.indval.out$pval <= 0.05]
vibi.new.thicket.kmeans2.fidg <- data.frame(group=vibi.new.thicket.kmeans2.gr, indval=vibi.new.thicket.kmeans2.iv, pvalue=vibi.new.thicket.kmeans2.pv, freq=vibi.new.thicket.kmeans2.fr)
vibi.new.thicket.kmeans2.fidg <- vibi.new.thicket.kmeans2.fidg[order(vibi.new.thicket.kmeans2.fidg$group, -vibi.new.thicket.kmeans2.fidg$indval),]
vibi.new.thicket.kmeans2.fidg
write.csv(vibi.new.thicket.kmeans2.fidg, file="vibi_new_thicket_indval_kmeans2_results_04192022.csv")

##combine k-means clusters with plot matrix
kmeans2_thicket_cluster <- vibi.new.thicket.hell.dist.kmeans2$cluster
vibi.new.thicket.kmeans2.cluster <- cbind(vibi.matrix.new.thicket, kmeans2_thicket_cluster)
write.csv(vibi.new.thicket.kmeans2.cluster, file="vibi_new_thicket_kmeans2_results_04192022.csv")


##run optsil function on k-means result from above
vibi.new.thicket.kmeans2.optsil <- optsil(kmeans2_thicket_cluster, vibi.matrix.new.thicket.hell.dist)
summary(vibi.new.thicket.kmeans2.optsil)
vibi.new.thicket.kmeans2.optsil$clustering
kmeans2_thicket_optsil_cluster <- vibi.new.thicket.kmeans2.optsil$clustering 
vibi.new.thicket.kmeans2.optsil.cluster <- cbind(vibi.matrix.new.thicket, kmeans2_thicket_optsil_cluster)
write.csv(vibi.new.thicket.kmeans2.optsil.cluster, file="vibi_new_thicket_kmeans2_optsil_results_04192022.csv")

##run indicator species analysis on kmeans7 + optsil results
vibi.new.thicket.kmeans2.optsil.indval.out = indval(vibi.matrix.new.thicket[,c(-1)], vibi.new.thicket.kmeans2.optsil$clustering, numitr=10000)

vibi.new.thicket.kmeans2.optsil.gr <- vibi.new.thicket.kmeans2.optsil.indval.out$maxcls[vibi.new.thicket.kmeans2.optsil.indval.out$pval <= 0.05]
vibi.new.thicket.kmeans2.optsil.iv <- vibi.new.thicket.kmeans2.optsil.indval.out$indcls[vibi.new.thicket.kmeans2.optsil.indval.out$pval <= 0.05]
vibi.new.thicket.kmeans2.optsil.pv <- vibi.new.thicket.kmeans2.optsil.indval.out$pval[vibi.new.thicket.kmeans2.optsil.indval.out$pval <= 0.05]
vibi.new.thicket.kmeans2.optsil.fr <- apply(vibi.matrix.new.thicket[,c(-1)] > 0, 2, sum)[vibi.new.thicket.kmeans2.optsil.indval.out$pval <= 0.05]
vibi.new.thicket.kmeans2.optsil.fidg <- data.frame(group=vibi.new.thicket.kmeans2.optsil.gr, indval=vibi.new.thicket.kmeans2.optsil.iv, pvalue=vibi.new.thicket.kmeans2.optsil.pv, freq=vibi.new.thicket.kmeans2.optsil.fr)
vibi.new.thicket.kmeans2.optsil.fidg <- vibi.new.thicket.kmeans2.optsil.fidg[order(vibi.new.thicket.kmeans2.optsil.fidg$group, -vibi.new.thicket.kmeans2.optsil.fidg$indval),]
vibi.new.thicket.kmeans2.optsil.fidg
write.csv(vibi.new.thicket.kmeans2.optsil.fidg, file="vibi_new_thicket_indval_kmeans2_optsil_results_04192022.csv")



##try randomForest for niche modelling (i.e., species habitat modeling)
library(randomForest)

ind <- sample(2,nrow(vibi.combined.class),replace=TRUE,prob=c(0.7,0.3))
trainData <- vibi.combined.class[ind==1,]
trainData
testData <- vibi.combined.class[ind==2,]

vibi.rf2 <- randomForest(as.factor(vibi.combined.cl.groups)~ ., data=trainData,ntree=10000, Importance = TRUE, proximity=TRUE)
vibi.rf2
plot(vibi.rf2)
table(predict(vibi.rf2),trainData$vibi.combined.cl.groups)
print(vibi.rf2)

Prediction <- predict(vibi.rf2, testData)
Prediction
Prediction.train <- predict(vibi.rf2, trainData)
Prediction.train
#submit <- data.frame(plot_id = testData$plot_id, Survived = Prediction)

#plot variable importance
varImpPlot(vibi.rf2)

#Try to see the margin, positive or negative, if positif it means correct classification

plot(margin(vibi.rf2,testData$vibi.combined.cl.groups))

#merge with cluster results to see which plots changed groups
vibi.combined.cl.rf.test.groups <- as.data.frame(Prediction)
vibi.combined.cl.rf.train.groups <- as.data.frame(Prediction.train)
names(vibi.combined.cl.rf.train.groups) <- "Prediction"
vibi.combined.cl.rf.groups <- rbind(vibi.combined.cl.rf.test.groups,vibi.combined.cl.rf.train.groups)
vibi.combined.cl.rf.groups <- merge(vibi.combined.class, vibi.combined.cl.rf.groups, by="row.names")
row.names(vibi.combined.cl.rf.groups) <- vibi.combined.cl.rf.groups[,1]
names(vibi.combined.cl.rf.groups)[1] <- "plot_id"
write.csv(vibi.combined.cl.rf.groups, file = "vibi_cluster_and_rf_results_02142022.csv", row.names = FALSE)


#now run indicator species analysis on new groups with reclassified plots
ncol(vibi.combined.cl.rf.groups)
names(vibi.combined.cl.rf.groups)
# remove plot_id and PYRBAC column
vibi.combined.rf.indval.out = indval(vibi.combined.matrix[,c(-1,-630)], vibi.combined.cl.rf.groups[,864], numitr=10000)

vibi.rf.gr <- vibi.combined.rf.indval.out$maxcls[vibi.combined.rf.indval.out$pval <= 0.05]
vibi.rf.iv <- vibi.combined.rf.indval.out$indcls[vibi.combined.rf.indval.out$pval <= 0.05]
vibi.rf.pv <- vibi.combined.rf.indval.out$pval[vibi.combined.rf.indval.out$pval <= 0.05]
vibi.rf.fr <- apply(vibi.combined.matrix[,c(-1,-630)] > 0, 2, sum)[vibi.combined.rf.indval.out$pval <= 0.05]
vibi.rf.fidg <- data.frame(group=vibi.rf.gr, indval=vibi.rf.iv, pvalue=vibi.rf.pv, freq=vibi.rf.fr)
vibi.rf.fidg <- vibi.rf.fidg[order(vibi.rf.fidg$group, -vibi.rf.fidg$indval),]
vibi.rf.fidg
write.csv(vibi.rf.fidg, file="vibi_indval_rf_results_02142022.csv")

##try some ordination
vibi.combined.nmds <- metaMDS(vibi.combined.hell, k = 2, try = 50, trymax = 50, autotransform=F)

# get levels from random forests groups
vibi.combined.rf.grp.lev <- unlist(vibi.combined.cl.rf.groups$Prediction)

#create color vector for points based on random forests results
col <- c("red", "blue", "green", "purple", "orange", "yellow")

# Combination with NMDS result
sit.sc <- scores(vibi.combined.nmds)
#sit.sc
dev.new()
p <- ordiplot(sit.sc,type="none", main="NMDS plot with RF class colors", choices=c(1,2))
points(sit.sc, pch=20, cex=0.8, col=col[vibi.combined.rf.grp.lev], bg=col[vibi.combined.rf.grp.lev])

# legend(locator(1), paste("Group",c(1:length(pcap.combined.forests.grp.lev))),
#        pch=14+c(1:length(pcap.combined.forests.grp.lev)), col=1+c(1:length(pcap.combined.forests.grp.lev)), pt.cex=2)

#legend with interpreted names from cluster/indval results
leg.txt <- c("Sugar Maple (Rich?)", "Beech-Mixed Hardwood (Hemlock)", "Alluvial Forest", "Red Maple", "Mixed Oak", "Ruderal Wet Early Successional")

legend("topright", leg.txt, 
       pch=20, col=col[], pt.cex=0.75, cex=0.50)

ordiellipse(vibi.combined.nmds, vibi.combined.rf.grp.lev, kind = "sd", conf=0.80, lwd=2, col="black")

# try 3D plotting if k = 3 in nmds above
# dev.new()
# p3d <- ordiplot3d(sit.sc, type="none", main="NMDS plot with RF class colors", choices=1:3)
# points(sit.sc, pch=20, cex=0.8, col=col[vibi.combined.rf.grp.lev], bg=col[vibi.combined.rf.grp.lev])





## ANALYSIS ON FOREST PLOTS ONLY ##
# query table with relative cover for non-tree species and IV for tree species
# pcap.forests.combined <- dbGetQuery(conn, "SELECT a.plot_id, a.species, b.acronym, a.relative_cover AS abundance FROM vibi.alt_herbaceous_relative_cover a LEFT JOIN vibi.species b ON a.species = b.scientific_name WHERE a.species NOT LIKE '%sp.%' AND b.form <> 'tree' AND a.plot_id LIKE '%_1st%' AND a.plot_id NOT LIKE '%3440%' AND a.plot_id NOT LIKE '%3405%' AND a.plot_id NOT IN (SELECT plot_id FROM nr_misc.hell_ward_cluster_assignments_pcap_combined_11282017 WHERE hell_ward_lvl1_grp = 6) AND a.plot_id IN (SELECT plot_id FROM nr_misc.pcap_env_variables_ssurgo_and_wetness)
# UNION
#                                     SELECT a.plot_id, a.species, b.acronym || '_1' as acronym, a.iv AS abundance FROM nr_misc.alt_reduced_fds2_iv_small a LEFT JOIN vibi.species b ON a.species = b.scientific_name WHERE a.species NOT LIKE '%sp.%' AND b.form = 'tree' AND a.plot_id LIKE '%_1st%' AND a.plot_id NOT LIKE '%3440%' AND a.plot_id NOT LIKE '%3405%' AND a.plot_id NOT IN (SELECT plot_id FROM nr_misc.hell_ward_cluster_assignments_pcap_combined_11282017 WHERE hell_ward_lvl1_grp = 6) AND a.plot_id IN (SELECT plot_id FROM nr_misc.pcap_env_variables_ssurgo_and_wetness)
#                                     UNION
#                                     SELECT a.plot_id, a.species, b.acronym || '_2' as acronym, a.iv AS abundance FROM nr_misc.alt_reduced_fds2_iv_big a LEFT JOIN vibi.species b ON a.species = b.scientific_name WHERE a.species NOT LIKE '%sp.%' AND b.form = 'tree' AND a.plot_id LIKE '%_1st%' AND a.plot_id NOT LIKE '%3440%' AND a.plot_id NOT LIKE '%3405%' AND a.plot_id NOT IN (SELECT plot_id FROM nr_misc.hell_ward_cluster_assignments_pcap_combined_11282017 WHERE hell_ward_lvl1_grp = 6) AND a.plot_id IN (SELECT plot_id FROM nr_misc.pcap_env_variables_ssurgo_and_wetness);")

#query view from database created from same query above (a bit faster)
vibi.forests.combined <- dbGetQuery(conn, "SELECT * FROM nr_misc.plot_data_for_veg_comm_analysis WHERE plot_id NOT IN
                                    (SELECT plot_id FROM nr_misc.plot_data_for_upland_vibi_development_with_geom WHERE group_description = 'Mesic Meadow                                      (Ruderal)');")

# reshape pcap_forests_combined into site X species matrix
vibi.forests.matrix <- cast(vibi.forests.combined, plot_id ~ acronym, value='abundance', fun="mean")

# vibi.forests.matrix
# edit(vibi.forests.matrix)
# str(vibi.forests.matrix, list.len = 999)
# names(vibi.forests.matrix)
# row.names(vibi.forests.matrix)


#examine vibi.forests.matrix table
#vibi.forests.matrix
row.names(vibi.forests.matrix) <- vibi.forests.matrix[ ,1]
names(vibi.forests.matrix)
nrow(vibi.forests.matrix)
ncol(vibi.forests.matrix)


##change NAs to 0
vibi.forests.matrix[is.na(vibi.forests.matrix)] <- 0

#remove species that occur in less than 5% of plots BUT NOT HEMLOCK
# pcap.forests <- pcap.forests[,colSums(pcap.forests != 0) > 18 | colnames(pcap.forests) == "TSUCAN_1" | colnames(pcap.forests) == "TSUCAN_2"] 
# names(pcap.forests)
# row.names(pcap.forests)
# 
# row.names(pcap.forests) <- pcap.forests[ ,c(1)]

# Wisconsin standardization: abundances are first ranged by species maxima and then by site totals
# pcap.forests.combined.wis <- wisconsin(pcap.forests)
# pcap.fds1.wis
# 
# pcap.forests.combined.wis <- pcap.forests.combined.wis[,colSums(pcap.forests.combined.wis != 0) > 18 | colnames(pcap.forests.combined.wis) == "TSUCAN_1" | colnames(pcap.forests.combined.wis) == "TSUCAN_2"]
# names(pcap.forests.combined.wis)
# edit(pcap.forests.combined.wis)
# 
# row.names(pcap.forests.combined.wis) <- pcap.forests.combined.wis[ ,c(1)]
# row.names(pcap.forests.combined.wis)




##Hellinger distance matrix
pcap.forests.combined.hell <- decostand(pcap.forests[,2:191], "hel", margin = 1)
##set row names to plot numbers in column 1
row.names(pcap.forests.combined.hell) <- pcap.forests[ ,c(1)]
row.names(pcap.forests.combined.hell) #check to see if row names are correct
pcap.forests.combined.hell.dist <- vegdist(pcap.forests.combined.hell, "euc")
head(pcap.forests.combined.hell.dist)
names(pcap.forests.combined.hell)

##Hellinger distance matrix with bray-curtis
pcap.forests.combined.hell <- decostand(pcap.forests[,2:191], "hel", margin = 1)
##set row names to plot numbers in column 1
row.names(pcap.forests.combined.hell) <- pcap.forests[ ,c(1)]
row.names(pcap.forests.combined.hell) #check to see if row names are correct
pcap.forests.combined.hell.bray.dist <- vegdist(pcap.forests.combined.hell, "bray")
head(pcap.forests.combined.hell.bray.dist)
names(pcap.forests.combined.hell.bray.dist)


##Ward's minimum variance clustering
pcap.forests.combined.clust.ward <- hclust(pcap.forests.combined.hell.dist, method = "ward.D")
pcap.forests.combined.clust.ward
plot(pcap.forests.combined.clust.ward)

pcap.forests.combined.cl.groups = cutree(pcap.forests.combined.clust.ward, k=5)
pcap.forests.combined.cl.groups

# write group assignemnt to csv to merge with data table for addtional analyses
# write.csv(pcap.forests.combined.cl.groups, file="hell_ward_cluster_assignments_pcap_forests_12242018.csv")


pcap.combined.clust.forests.reorder <- reorder.hclust(pcap.forests.combined.clust.ward, pcap.forests.combined.hell.dist)
pcap.combined.clust.forests.reorder

source("hcoplot.R")
hcoplot(pcap.combined.clust.forests.reorder, pcap.forests.combined.hell.dist, k=5)



#test signficance of group differences with MRPP
#first add new column with cluster group
pcap.forests <-cbind(pcap.forests,pcap.forests.combined.cl.groups)
names(pcap.forests)
colnames(pcap.forests)[192] <- "forest_group"
names(pcap.forests)
#pcap.forest.grp.bind
#run MRPP
pcap.combined.forest.mrpp <- mrpp(pcap.forests.combined.hell, pcap.forests$forest_group)
pcap.combined.forest.mrpp

##try some indicator species analysis##

#first using IndVal function#

# Look for the indicator species in ward clustering
pcap.combined.forests.indval.out = indval(pcap.forests[,2:191], pcap.forests.combined.cl.groups, numitr=10000)
summary(pcap.combined.forests.indval.out)

# Table of the significant indicator species
gr <- pcap.combined.forests.indval.out$maxcls[pcap.combined.forests.indval.out$pval <= 0.05]
iv <- pcap.combined.forests.indval.out$indcls[pcap.combined.forests.indval.out$pval <= 0.05]
pv <- pcap.combined.forests.indval.out$pval[pcap.combined.forests.indval.out$pval <= 0.05]
fr <- apply(pcap.forests[,2:191] > 0, 2, sum)[pcap.combined.forests.indval.out$pval <= 0.05]
fidg <- data.frame(group=gr, indval=iv, pvalue=pv, freq=fr)
fidg <- fidg[order(fidg$group, -fidg$indval),]
fidg

#try indicator species analysis using multipatt function (see references)
pcap.multipatt <- multipatt(pcap.forests[,2:191], pcap.forests.combined.cl.groups, control = how(nperm=999))
summary(pcap.multipatt)

## customize final dendrogram with dendextend
dend.pcap.forests.combined <- as.dendrogram(pcap.combined.clust.forests.reorder, hang=-3)


# Get various attributes (just an example)
#dend.pcap.forests %>% get_nodes_attr("height")

# work on drawing rectangles around clusters
dev.new()
dend.pcap.forests.combined %>% plot(leaflab = "none");
dend %>% set("hang_labels", 3) %>% plot
text(17,-0.8, "(I) Mesic Beech-
     Mixed Hardwood 
     (Hemlock) Forest", cex=0.85, font=4, xpd=NA);
text(70,-0.5, "(II) Mixed Mesic Forest", cex=0.85, font=4);
text(150,-0.6, "(III) Palustrine Red Maple-Mixed Hardwood 
     Forest", cex=0.85, font=4, xpd=NA);
text(308,-0.5, "(V) Alluvial Forest", cex=0.85, font=4);
text(220,-0.6, "(IV) Dry-Mesic 
     Oak-Mixed Hardwood Forest", cex=0.85, font=4, xpd=NA)

dend.pcap.forests.combined %>% rect.dendrogram(k=5, 
                                      border = 1, lty = 2, lwd = 3, lower_rect = -2)  %>% plot

#build species constancy table
pcap.forests.groups.constancy <- const(pcap.forests[,2:191], pcap.forests.combined.cl.groups)
pcap.forests.groups.constancy
#write.csv(pcap.forests.groups.constancy, file="pcap_forests_group_constancy_12182017.csv")

#get mean species abundances
pcap.forests.groups.importance <- importance(pcap.forests[,2:191], pcap.forests.combined.cl.groups, digits=3)
pcap.forests.groups.importance
write.csv(pcap.forests.groups.importance, file="pcap_forests_group_importance_12182017.csv")

#table that combines species constancy with mean abundance by group
pcap.forests.groups.abundance <- concov(pcap.forests[,2:191], pcap.forests.combined.cl.groups)
pcap.forests.groups.abundance
write.csv(pcap.forests.groups.abundance, file="pcap_forests_constancy_coverage_12182017.csv")

##try some ordination

pcap.combined.forests.nmds <- metaMDS(pcap.forests.combined.hell, k = 3, try = 100, trymax = 100, autotransform=T)
#pcap.combined.forests.nmds
pcap.combined.forests.nmds$stress
#scores(pcap.combined.forests.nmds)

#check with stressplot
stressplot(pcap.combined.forests.nmds)

#another attempt to check goodness of fit
# gof.pcap.combined.forests <- goodness(pcap.combined.forests.nmds)
# plot(pcap.combined.forests.nmds, type = "t", main="Goodness of fit")
# points(pcap.combined.forests.nmds, display = "sites", cex=gof.pcap.combined.forests*2)

#one way to check stress vs. dimensionality
#dimcheckMDS(pcap.forests.combined.hell, distance = "euclidean", k = 6, trymax = 20,
#              autotransform = FALSE)

#basic nmds plot
# dev.new(title="NMDS on PCAP plots - Percentage difference")
# plot(pcap.combined.forests.nmds, type="n", main=paste("NMDS/Percentage difference - Stress =", round(pcap.combined.forests.nmds$stress,3)))

# get levels from cluster groups
pcap.combined.forests.grp.lev <- levels(factor(pcap.forests.combined.cl.groups))
pcap.combined.forests.grp.lev

# Combination with NMDS result
sit.sc <- scores(pcap.combined.forests.nmds,choices = c(1, 2))
dev.new(title="NMDS plot with cluster colors")
p <- ordiplot(sit.sc,type="n", main="")
for (i in 1:length(pcap.combined.forests.grp.lev))
{
  points(sit.sc[pcap.forests.combined.cl.groups==i,], pch=(14+i), cex=1.5, col=i+1)
}

# legend(locator(1), paste("Group",c(1:length(pcap.combined.forests.grp.lev))),
#        pch=14+c(1:length(pcap.combined.forests.grp.lev)), col=1+c(1:length(pcap.combined.forests.grp.lev)), pt.cex=2)

#legend with interpreted names from cluster/indval results
leg.txt <- c("Mixed Mesic", "Beech-Mixed Hardwood",
             "Alluvial", "Palustrine Red Maple", "Dry-Mesic")

legend("topright", leg.txt, 
       pch=14+c(1:length(pcap.combined.forests.grp.lev)), col=1+c(1:length(pcap.combined.forests.grp.lev)), pt.cex=1.5, cex=0.75)

ordiellipse(pcap.combined.forests.nmds, pcap.forests.combined.cl.groups, kind = "sd", conf=0.80, lwd=2, col="black")

#get environmnetal variables for these plots
pcap.forests.combined.env <- dbGetQuery(conn, "SELECT * FROM nr_misc.pcap_env_variables_ssurgo_and_wetness WHERE plot_id IN (SELECT plot_id FROM nr_misc.pcap_forests_spp_matrix);")

##look at table
pcap.forests.combined.env
#edit(pcap.forests.combined.env)
#str(pcap.forests.combined.env, list.len = 999)
names(pcap.forests.combined.env)
row.names(pcap.forests.combined.env)

##set row names to plot numbers in column 1
row.names(pcap.forests.combined.env) <- pcap.forests.combined.env[ ,c(1)]
row.names(pcap.forests.combined.env) #check to see if row names are correct

# create data frame that includes plot_id and cluster group id
env.grp <- data.frame(pcap.forests$plot_id, pcap.forests$forest_group) #make sure you've run code earlier to create "forest_group" variable
env.grp
pcap.forests.combined.env.grp <- merge(pcap.forests.combined.env, env.grp, by.x = "plot_id", by.y = "pcap.forests.plot_id")
pcap.forests.combined.env.grp
edit(pcap.forests.combined.env.grp)
names(pcap.forests.combined.env.grp)

#create factor from group assignment
as.factor(pcap.forests.combined.env.grp$pcap.forests.forest_group)

#change some column names
colnames(pcap.forests.combined.env.grp)[2] <- "om"
colnames(pcap.forests.combined.env.grp)[20] <- "openness"

names(pcap.forests.combined.env.grp)

row.names(pcap.forests.combined.env.grp) <- pcap.forests.combined.env.grp[ ,c(1)]
row.names(pcap.forests.combined.env.grp) #check to see if row names are correct


#look at boxplots of env variables
par(mfrow=c(2,2))

boxplot(pcap.forests.combined.env$ph, las=1, main = "ph")
boxplot(log(pcap.forests.combined.env$sand), las=1, main = "log(sand)")
boxplot(sqrt(pcap.forests.combined.env$silt), las=1, main = "sqrt(silt)")
boxplot(pcap.forests.combined.env$clay, las=1, main = "clay")
boxplot(pcap.forests.combined.env$wetness, las=1, main = "wetness")
boxplot(sqrt(pcap.forests.combined.env$slope), las=1, main = "sqrt(slope)")
boxplot(sqrt(pcap.forests.combined.env$alluvium), las=1, main = "sqrt(alluvium)")
boxplot(pcap.forests.combined.env$aspect, las=1, main = "aspect")
boxplot(pcap.forests.combined.env$northness, las=1, main = "northness")
boxplot(pcap.forests.combined.env$eastness, las=1, main = "eastness")
boxplot(sqrt(pcap.forests.combined.env$"% open"), las=1, main = "sqrt(% open)")
boxplot(sqrt(pcap.forests.combined.env$cec), las=1, main = "sqrt(cec)")
boxplot(sqrt(pcap.forests.combined.env$"% organic matter"), las=1, main = "sqrt(% organic matter)")
boxplot(sqrt(pcap.forests.combined.env$phos1_ppm), las=1, main = "sqrt(phos1_ppm)")
boxplot(sqrt(pcap.forests.combined.env$phos2_ppm), las=1, main = "sqrt(phos2_ppm)")
boxplot(sqrt(pcap.forests.combined.env$k_ppm), las=1, main = "sqrt(k_ppm)")
boxplot(sqrt(pcap.forests.combined.env$mg_ppm), las=1, main = "sqrt(mg_ppm)")
boxplot(sqrt(pcap.forests.combined.env$ca_ppm), las=1, main = "sqrt(ca_ppm)")
boxplot(sqrt(pcap.forests.combined.env$perc_base_k), las=1, main = "sqrt(perc_base_k)")
boxplot(sqrt(pcap.forests.combined.env$perc_base_mg), las=1, main = "sqrt(perc_base_mg)")
boxplot(sqrt(pcap.forests.combined.env$perc_base_ca), las=1, main = "sqrt(perc_base_ca)")
boxplot(sqrt(pcap.forests.combined.env$tot_carbon), las=1, main = "sqrt(tot_carbon)")
boxplot(sqrt(pcap.forests.combined.env$tot_nitrogen), las=1, main = "sqrt(tot_nitrogen)")
boxplot(sqrt(pcap.forests.combined.env$tot_nitrogen), las=1, main = "sqrt(tot_nitrogen)")
boxplot(log(pcap.forests.combined.env$c_n_ratio), las=1, main = "log(c_n_ratio)")

dev.off()

#test for normality
shapiro.test(pcap.forests.combined.env$ph)
qqnorm(pcap.forests.combined.env$ph)
shapiro.test(log(pcap.forests.combined.env$sand))
qqnorm(log(pcap.forests.combined.env$sand))
shapiro.test(sqrt(pcap.forests.combined.env$silt))
qqnorm(sqrt(pcap.forests.combined.env$silt))
shapiro.test(pcap.forests.combined.env$clay)
qqnorm(pcap.forests.combined.env$clay)

#look at boxplot of continuous env variables by group
par(mfrow=c(2,2))

boxplot(ph ~ pcap.forests.forest_group, data = pcap.forests.combined.env.grp, las=1, main = "ph")
boxplot(log(sand) ~ pcap.forests.forest_group, data = pcap.forests.combined.env.grp, las=1, main = "log(sand)")
boxplot(sqrt(silt) ~ pcap.forests.forest_group, data = pcap.forests.combined.env.grp, las=1, main = "sqrt(silt)")
boxplot(clay ~ pcap.forests.forest_group, data = pcap.forests.combined.env.grp, las=1, main = "clay")
boxplot(wetness ~ pcap.forests.forest_group, data = pcap.forests.combined.env.grp, las=1, main = "wetness")
boxplot(sqrt(slope) ~ pcap.forests.forest_group, data = pcap.forests.combined.env.grp, las=1, main = "sqrt(slope)")
boxplot(northness ~ pcap.forests.forest_group, data = pcap.forests.combined.env.grp, las=1, main = "northness")
boxplot(eastness ~ pcap.forests.forest_group, data = pcap.forests.combined.env.grp, las=1, main = "eastness")
boxplot(sqrt(openness) ~ pcap.forests.forest_group, data = pcap.forests.combined.env.grp, las=1, main = "sqrt(% open)")
boxplot(sqrt(cec) ~ pcap.forests.forest_group, data = pcap.forests.combined.env.grp, las=1, main = "sqrt(cec)")
boxplot(sqrt(om) ~ pcap.forests.forest_group, data = pcap.forests.combined.env.grp, las=1, main = "sqrt(% organic matter)")
boxplot(sqrt(phos1_ppm) ~ pcap.forests.forest_group, data = pcap.forests.combined.env.grp, las=1, main = "sqrt(phos1_ppm)")
boxplot(sqrt(phos2_ppm) ~ pcap.forests.forest_group, data = pcap.forests.combined.env.grp, las=1, main = "sqrt(phos2_ppm)")
boxplot(sqrt(k_ppm) ~ pcap.forests.forest_group, data = pcap.forests.combined.env.grp, las=1, main = "sqrt(k_ppm)")
boxplot(sqrt(mg_ppm) ~ pcap.forests.forest_group, data = pcap.forests.combined.env.grp, las=1, main = "sqrt(mg_ppm)")
boxplot(sqrt(ca_ppm) ~ pcap.forests.forest_group, data = pcap.forests.combined.env.grp, las=1, main = "sqrt(ca_ppm)")
boxplot(sqrt(perc_base_k) ~ pcap.forests.forest_group, data = pcap.forests.combined.env.grp, las=1, main = "sqrt(perc_base_k)")
boxplot(sqrt(perc_base_mg) ~ pcap.forests.forest_group, data = pcap.forests.combined.env.grp, las=1, main = "sqrt(perc_base_mg)")
boxplot(sqrt(perc_base_ca) ~ pcap.forests.forest_group, data = pcap.forests.combined.env.grp, las=1, main = "sqrt(perc_base_ca)")
boxplot(sqrt(tot_carbon) ~ pcap.forests.forest_group, data = pcap.forests.combined.env.grp, las=1, main = "sqrt(tot_carbon)")
boxplot(sqrt(tot_nitrogen) ~ pcap.forests.forest_group, data = pcap.forests.combined.env.grp, las=1, main = "sqrt(tot_nitrogen)")
boxplot(sqrt(tot_nitrogen) ~ pcap.forests.forest_group, data = pcap.forests.combined.env.grp, las=1, main = "sqrt(tot_nitrogen)")
boxplot(log(c_n_ratio) ~ pcap.forests.forest_group, data = pcap.forests.combined.env.grp, las=1, main = "log(c_n_ratio)")

dev.off()

#test significance of env variables
#ph
pcap.ph.aov <- aov(ph ~ as.factor(pcap.forests.forest_group), data = pcap.forests.combined.env.grp)
summary(pcap.ph.aov)
TukeyHSD(pcap.ph.aov)

#slope
pcap.slope.aov <- aov(sqrt(slope) ~ as.factor(pcap.forests.forest_group), data = pcap.forests.combined.env.grp)
summary(pcap.slope.aov)
TukeyHSD(pcap.slope.aov)

#wetness
pcap.wetness.aov <- aov(wetness ~ as.factor(pcap.forests.forest_group), data = pcap.forests.combined.env.grp)
summary(pcap.wetness.aov)
TukeyHSD(pcap.wetness.aov)

#% organic matter
pcap.om.aov <- aov(sqrt(pcap.forests.combined.env$"% organic matter") ~ as.factor(pcap.forests.forest_group), data = pcap.forests.combined.env.grp)
summary(pcap.om.aov)
TukeyHSD(pcap.om.aov)

#% open
pcap.open.aov <- aov(sqrt(pcap.forests.combined.env$"% open") ~ as.factor(pcap.forests.forest_group), data = pcap.forests.combined.env.grp)
summary(pcap.open.aov)
TukeyHSD(pcap.open.aov)

#% clay
pcap.clay.aov <- aov(clay ~ as.factor(pcap.forests.forest_group), data = pcap.forests.combined.env.grp)
summary(pcap.clay.aov)
TukeyHSD(pcap.clay.aov)

#% sand
pcap.sand.aov <- aov(log(sand) ~ as.factor(pcap.forests.forest_group), data = pcap.forests.combined.env.grp)
summary(pcap.sand.aov)
TukeyHSD(pcap.sand.aov)

#% silt
pcap.silt.aov <- aov(sqrt(silt) ~ as.factor(pcap.forests.forest_group), data = pcap.forests.combined.env.grp)
summary(pcap.silt.aov)
TukeyHSD(pcap.silt.aov)

#aspect
pcap.aspect.aov <- aov(aspect ~ as.factor(pcap.forests.forest_group), data = pcap.forests.combined.env.grp)
summary(pcap.aspect.aov)
TukeyHSD(pcap.aspect.aov)

#create env data frame with transformed variables and rename appropriately
pcap.forests.combined.env.grp.trans <- pcap.forests.combined.env.grp

pcap.forests.combined.env.grp.trans$sand <- log(pcap.forests.combined.env.grp.trans$sand)
colnames(pcap.forests.combined.env.grp.trans)[22] <- "log.sand"
pcap.forests.combined.env.grp.trans$silt <- sqrt(pcap.forests.combined.env.grp.trans$silt)
colnames(pcap.forests.combined.env.grp.trans)[23] <- "sqrt.silt"
pcap.forests.combined.env.grp.trans$slope <- sqrt(pcap.forests.combined.env.grp.trans$slope)
colnames(pcap.forests.combined.env.grp.trans)[16] <- "sqrt.slope"
pcap.forests.combined.env.grp.trans$openness <- sqrt(pcap.forests.combined.env.grp.trans$openness)
colnames(pcap.forests.combined.env.grp.trans)[20] <- "sqrt.open"
pcap.forests.combined.env.grp.trans$cec <- sqrt(pcap.forests.combined.env.grp.trans$cec)
colnames(pcap.forests.combined.env.grp.trans)[9] <- "sqrt.cec"
pcap.forests.combined.env.grp.trans$om <- sqrt(pcap.forests.combined.env.grp.trans$om)
colnames(pcap.forests.combined.env.grp.trans)[2] <- "sqrt.om"
pcap.forests.combined.env.grp.trans$phos1_ppm <- sqrt(pcap.forests.combined.env.grp.trans$phos1_ppm)
colnames(pcap.forests.combined.env.grp.trans)[3] <- "sqrt.phos1_ppm"
pcap.forests.combined.env.grp.trans$phos2_ppm <- sqrt(pcap.forests.combined.env.grp.trans$phos2_ppm)
colnames(pcap.forests.combined.env.grp.trans)[4] <- "sqrt.phos2_ppm"
pcap.forests.combined.env.grp.trans$k_ppm <- sqrt(pcap.forests.combined.env.grp.trans$k_ppm)
colnames(pcap.forests.combined.env.grp.trans)[5] <- "sqrt.k_ppm"
pcap.forests.combined.env.grp.trans$mg_ppm <- sqrt(pcap.forests.combined.env.grp.trans$mg_ppm)
colnames(pcap.forests.combined.env.grp.trans)[6] <- "sqrt.mg_ppm"
pcap.forests.combined.env.grp.trans$ca_ppm <- sqrt(pcap.forests.combined.env.grp.trans$ca_ppm)
colnames(pcap.forests.combined.env.grp.trans)[7] <- "sqrt.ca_ppm"
pcap.forests.combined.env.grp.trans$perc_base_k <- sqrt(pcap.forests.combined.env.grp.trans$perc_base_k)
colnames(pcap.forests.combined.env.grp.trans)[10] <- "sqrt.perc_base_k"
pcap.forests.combined.env.grp.trans$perc_base_mg <- sqrt(pcap.forests.combined.env.grp.trans$perc_base_mg)
colnames(pcap.forests.combined.env.grp.trans)[11] <- "sqrt.perc_base_mg"
pcap.forests.combined.env.grp.trans$perc_base_ca <- sqrt(pcap.forests.combined.env.grp.trans$perc_base_ca)
colnames(pcap.forests.combined.env.grp.trans)[12] <- "sqrt.perc_base_ca"
pcap.forests.combined.env.grp.trans$tot_carbon <- sqrt(pcap.forests.combined.env.grp.trans$tot_carbon)
colnames(pcap.forests.combined.env.grp.trans)[13] <- "sqrt.tot_carbon"
pcap.forests.combined.env.grp.trans$tot_nitrogen <- sqrt(pcap.forests.combined.env.grp.trans$tot_nitrogen)
colnames(pcap.forests.combined.env.grp.trans)[14] <- "sqrt.tot_nitrogen"
pcap.forests.combined.env.grp.trans$c_n_ratio <- log(pcap.forests.combined.env.grp.trans$c_n_ratio)
colnames(pcap.forests.combined.env.grp.trans)[15] <- "log.c_n_ratio"



edit(pcap.forests.combined.env.grp.trans)
row.names(pcap.forests.combined.env.grp.trans)
names(pcap.forests.combined.env.grp.trans)


# standardize env variables
pcap.forests.combined.env.std <- decostand(pcap.forests.combined.env.grp[,2:25], "standardize")
pcap.forests.combined.env.std
names(pcap.forests.combined.env.std)

##get subsets of env variables

#subset of those thoughth to be important
pcap.env.sub <- pcap.forests.combined.env.std[ ,c(3,7,15,19,20,24)]

#subset of soil variables from lab analysis
pcap.env.soil.sub <- pcap.forests.combined.env.std[ ,c(2:15)]

#subset of environmental variables derived from GIS analysis
pcap.env.derived.sub <- pcap.forests.combined.env.std[ ,c(16:25)]

# fit to ordination
pcap.combined.forests.env.fit <- envfit(pcap.combined.forests.nmds, pcap.env.sub, permu = 999, p.max = 0.05, choices = c(1, 2))
pcap.combined.forests.env.fit

# add vectors to ordination plot
plot(pcap.combined.forests.env.fit, col = "black", font=1)

# try CCA
pcap.combined.forests.cca <- cca(pcap.forests[,2:189] ~ ., env.rda1[,2:25])
pcap.combined.forests.cca
summary(pcap.combined.forests.cca)

# Unadjusted R^2
RsquareAdj(pcap.combined.forests.cca)

## CCA triplots (using lc site scores)
dev.new(title="CCA triplot - lc scores", width=14, height=7)
par(mfrow=c(1,2))
# Scaling 1: species scores scaled to relative eigenvalues, 
# sites are weighted averages of the species
plot(pcap.combined.forests.cca, scaling=1, display=c("sp","lc","cn"), 
     main="Triplot CCA spe ~ env2 - scaling 1")
# Default scaling 2: site scores scaled to relative eigenvalues, 
# species are weighted averages of the sites
plot(pcap.combined.forests.cca, display=c("sp","lc","cn"), 
     main="Triplot CCA spe ~ env2 - scaling 2")

dev.new(title="CCA biplot - without species", width=14, height=7)
par(mfrow=c(1,2))
# CCA scaling 1 biplot without species (using lc site scores)
plot(pcap.combined.forests.cca, scaling=1, display=c("lc", "cn"), 
     main="Biplot CCA spe ~ env - scaling 1")
# CCA scaling 2 biplot with species but without sites
plot(pcap.combined.forests.cca, scaling=2, display=c("sp", "cn"), 
     main="Biplot CCA spe ~ env2 - scaling 2")

# Permutation test of the overall analysis
anova(pcap.combined.forests.cca, permutations=how(nperm=999))
# Permutation test of each axis
anova(pcap.combined.forests.cca, by="axis", permutations=how(nperm=999))


# try RDA (redundancy analysis)
# RDA of the Hellinger-transformed species data, constrained
# by all the environmental variables
#first crate env data table with appropriate transformations
env.rda1 <- pcap.forests.combined.env

env.rda1$sand <- log(env.rda1$sand)
env.rda1$silt <- sqrt(env.rda1$silt)
env.rda1$slope <- sqrt(env.rda1$slope)
env.rda1$"% open" <- sqrt(env.rda1$"% open")
env.rda1$cec <- sqrt(env.rda1$cec)
env.rda1$"% organic matter" <- sqrt(env.rda1$"% organic matter")
env.rda1$phos1_ppm <- sqrt(env.rda1$phos1_ppm)
env.rda1$phos2_ppm <- sqrt(env.rda1$phos2_ppm)
env.rda1$k_ppm <- sqrt(env.rda1$k_ppm)
env.rda1$mg_ppm <- sqrt(env.rda1$mg_ppm)
env.rda1$ca_ppm <- sqrt(env.rda1$ca_ppm)
env.rda1$perc_base_k <- sqrt(env.rda1$perc_base_k)
env.rda1$perc_base_mg <- sqrt(env.rda1$perc_base_mg)
env.rda1$perc_base_ca <- sqrt(env.rda1$perc_base_ca)
env.rda1$tot_carbon <- sqrt(env.rda1$tot_carbon)
env.rda1$tot_nitrogen <- sqrt(env.rda1$tot_nitrogen)
env.rda1$c_n_ratio <- log(env.rda1$c_n_ratio)

edit(env.rda1)
row.names(env.rda1)
names(env.rda1)



pcap.rda <- rda(pcap.forests.combined.hell ~ ., env.rda1[ ,c(8,9,15,16,20,21,23,24,25)]) # Observe the shortcut
# formula
summary(pcap.rda)	# Scaling 2 (default)
## Limited output of 'summary'
head(summary(pcap.rda))


# Canonical coefficients from the rda object
coef(pcap.rda)
# Unadjusted R^2 retrieved from the rda object
RsquareAdj(pcap.rda)$r.squared

# Adjusted R^2 retrieved from the rda object
RsquareAdj(pcap.rda)$adj.r.squared

## Triplots of the rda results (wa scores)
## Site scores as weighted averages (vegan's default)
# Scaling 1: distance triplot
dev.new(title="RDA scaling 1 + wa")
plot(pcap.rda, scaling=1, 
     main="Triplot RDA pcap.hel ~ env - scaling 1 - wa scores")
pcap.sc1 <- scores(pcap.rda, choices=1:2, scaling=1, display="sp")
#pcap.sc1
arrows(0, 0, pcap.sc1[, 1]*0.92, pcap.sc1[, 2]*0.92, length=0, lty=1, col="red")

# Scaling 2 (default): correlation triplot
dev.new(title="RDA scaling 2 + wa")
plot(pcap.rda, main="Triplot RDA pcap.hel ~ env - scaling 2 - wa scores")
pcap.sc2 <- scores(pcap.rda, choices=1:2, display="sp")
arrows(0, 0, pcap.sc2[, 1]*0.92, pcap.sc2[, 2]*0.92, length=0, lty=1, col="red")


##try some classification using randomForest package
library(randomForest)
# query env matrix with group assignment from cluster analysis; group assignemnt will be repsonse variable for randomForest
# create data frame that includes plot_id and cluster group id

# pcap.env.rf.data <- merge(pcap.forests.combined.env.grp, env.grp, by.x = "plot_id", by.y = "pcap.forests.plot_id")
# pcap.env.rf.data
# edit(pcap.env.rf.data)
# names(pcap.env.rf.data)



##create subsets of data##

#soil variables only
pcap.forests.combined.env.grp.soil <- pcap.forests.combined.env.grp[,c(2:15,26)]
names(pcap.forests.combined.env.grp.soil)
#look at correlation matrix
cor(pcap.forests.combined.env.grp[,c(2:15)])

#landscape variables only
pcap.forests.combined.env.grp.landscape <- pcap.forests.combined.env.grp[,c(16:26)]
names(pcap.forests.combined.env.grp.landscape)
cor(pcap.forests.combined.env.grp[,c(16:25)])

#correlation matric of all variables
cor(pcap.forests.combined.env.grp[,c(2:26)])


##run randomForest function on full environmental data set (or subset that combines most important soil and landscape variables)

#split data into test and train sets
ind <- sample(2,nrow(pcap.forests.combined.env.grp.trans[,c(2:26)]),replace=TRUE,prob=c(0.7,0.3))
trainData <- pcap.forests.combined.env.grp.trans[,c(2:26)][ind==1,]
trainData
testData <- pcap.forests.combined.env.grp.trans[,c(2:26)][ind==2,]

#run randomForest
pcap.env.rf2 <- randomForest(as.factor(pcap.forests.forest_group)~ ., data=trainData, ntree=10000, mtry=4, Importance = TRUE, proximity=TRUE)
pcap.env.rf2
plot(pcap.env.rf2)
table(predict(pcap.env.rf2),trainData$pcap.forests.forest_group)
print(pcap.env.rf2)

Prediction <- predict(pcap.env.rf2, testData)
Prediction
submit <- data.frame(plot_id = testData$plot_id, Survived = Prediction)
#write.csv(submit, file = "firstforest_pcap_env_test.csv", row.names = FALSE)

#plot variable importance
varImpPlot(pcap.env.rf2)

#Try to see the margin, positive or negative, if positif it means correct classification

plot(margin(pcap.env.rf2,testData$pcap.forests.forest_group))

#Try to tune Random Forest
bestmtry <- tuneRF(pcap.forests.combined.env.grp[,c(2:25)], as.factor(pcap.forests.combined.env.grp[,26]), stepFactor=1.5, improve=1e-5, ntree=500)

#confusionMatrix function from caret package can be used for creating confusion matrix based on actual response variable and predicted value.
trainData$predicted.response <- predict(pcap.env.rf2, trainData)

# Create Confusion Matrix
confusionMatrix(data=trainData$predicted.response,
                reference=trainData$pcap.forests.forest_group,
                positive='yes')


#validation (test) data
# Predicting response variable
testData$predicted.response <- predict(pcap.env.rf2, testData)

# Create Confusion Matrix
confusionMatrix(data=testData$predicted.response,
                reference=testData$pcap.forests.forest_group,
                positive='yes')


##now try with soil chemistry data only

ind <- sample(2,nrow(pcap.forests.combined.env.grp.soil),replace=TRUE,prob=c(0.7,0.3))
trainData <- pcap.forests.combined.env.grp.soil[ind==1,]
trainData
testData <- pcap.forests.combined.env.grp.soil[ind==2,]

pcap.env.soil.rf2 <- randomForest(as.factor(pcap.forests.forest_group)~ ., data=trainData, mtry=4, ntree=10000, Importance = TRUE, proximity=TRUE)
pcap.env.soil.rf2
plot(pcap.env.soil.rf2)
table(predict(pcap.env.soil.rf2),trainData$pcap.forests.forest_group)
print(pcap.env.soil.rf2)

Prediction <- predict(pcap.env.soil.rf2, testData)
Prediction
submit <- data.frame(plot_id = testData$plot_id, Survived = Prediction) #error because plot_id not in data frame
#write.csv(submit, file = "firstforest_pcap_env_test.csv", row.names = FALSE)

#plot variable importance
varImpPlot(pcap.env.soil.rf2)

#Try to see the margin, positive or negative, if positif it means correct classification

plot(margin(pcap.env.soil.rf2,testData$pcap.forests.forest_group))

#Try to tune Random Forest
bestmtry <- tuneRF(pcap.forests.combined.env.grp.soil[,-15], as.factor(pcap.forests.combined.env.grp.soil[,15]), stepFactor=1.5, improve=1e-5, ntree=500)

#confusionMatrix function from caret package can be used for creating confusion matrix based on actual response variable and predicted value.
trainData$predicted.response <- predict(pcap.env.soil.rf2, trainData)

# Create Confusion Matrix
confusionMatrix(data=trainData$predicted.response,
                reference=trainData$pcap.forests.forest_group,
                positive='yes')


#validation (test) data
# Predicting response variable
testData$predicted.response <- predict(pcap.env.soil.rf2, testData)

# Create Confusion Matrix
confusionMatrix(data=testData$predicted.response,
                reference=testData$pcap.forests.forest_group,
                positive='yes')

##now try with GIS-derived landscape data only

ind <- sample(2,nrow(pcap.forests.combined.env.grp.landscape),replace=TRUE,prob=c(0.7,0.3))
trainData <- pcap.forests.combined.env.grp.landscape[ind==1,]
trainData
testData <- pcap.forests.combined.env.grp.landscape[ind==2,]

pcap.env.landscape.rf2 <- randomForest(as.factor(pcap.forests.forest_group)~ ., data=trainData, mtry=4, ntree=5000, Importance = TRUE, proximity=TRUE)
pcap.env.landscape.rf2
plot(pcap.env.landscape.rf2)
table(predict(pcap.env.landscape.rf2),trainData$pcap.forests.forest_group)
print(pcap.env.landscape.rf2)

Prediction <- predict(pcap.env.landscape.rf2, testData)
Prediction
submit <- data.frame(plot_id = testData$plot_id, Survived = Prediction) #error because plot_id not in data frame
#write.csv(submit, file = "firstforest_pcap_env_test.csv", row.names = FALSE)

#plot variable importance
varImpPlot(pcap.env.landscape.rf2)

#Try to see the margin, positive or negative, if positif it means correct classification

plot(margin(pcap.env.landscape.rf2,testData$pcap.forests.forest_group))

#Try to tune Random Forest
set.seed(411)
bestmtry <- tuneRF(pcap.forests.combined.env.grp.landscape[,-11], as.factor(pcap.forests.combined.env.grp.landscape[,11]), stepFactor=1.5, improve=1e-5, ntree=500)

#confusionMatrix function from caret package can be used for creating confusion matrix based on actual response variable and predicted value.
trainData$predicted.response <- predict(pcap.env.landscape.rf2, trainData)

# Create Confusion Matrix
confusionMatrix(data=trainData$predicted.response,
                reference=trainData$pcap.forests.forest_group,
                positive='yes')


#validation (test) data
# Predicting response variable
testData$predicted.response <- predict(pcap.env.landscape.rf2, testData)

# Create Confusion Matrix
confusionMatrix(data=testData$predicted.response,
                reference=testData$pcap.forests.forest_group,
                positive='yes')



##run randomForest function on subset of "best" environmental variables (based on RF modelling of separate sets above)
## not sure how much we gain here becasue I think RF should pick the best combination of variables when run on full data set??

names(pcap.forests.combined.env.grp)

ind <- sample(2,nrow(pcap.forests.combined.env.grp[,c(4,12,16,18,20,24,25,26)]),replace=TRUE,prob=c(0.7,0.3))
trainData <- pcap.forests.combined.env.grp[,c(4,12,16,18,20,24,25,26)][ind==1,]
trainData
testData <- pcap.forests.combined.env.grp[,c(4,12,16,18,20,24,25,26)][ind==2,]

pcap.env.rf.sub <- randomForest(as.factor(pcap.forests.forest_group)~ ., data=trainData, mtry=3, ntree=10000, Importance = TRUE, proximity=TRUE)
pcap.env.rf.sub
plot(pcap.env.rf.sub)
table(predict(pcap.env.rf.sub),trainData$pcap.forests.forest_group)
print(pcap.env.rf.sub)

Prediction <- predict(pcap.env.rf.sub, testData)
Prediction
submit <- data.frame(plot_id = testData$plot_id, Survived = Prediction)
#write.csv(submit, file = "firstforest_pcap_env_test.csv", row.names = FALSE)

#plot variable importance
varImpPlot(pcap.env.rf.sub)

#Try to see the margin, positive or negative, if positif it means correct classification

plot(margin(pcap.env.rf.sub,testData$pcap.forests.forest_group))

#Try to tune Random Forest
set.seed(189)
bestmtry <- tuneRF(pcap.forests.combined.env.grp[,c(4,12,16,18,20,24,25)], as.factor(pcap.forests.combined.env.grp[,26]), stepFactor=1.5, improve=1e-5, ntree=500)

#confusionMatrix function from caret package can be used for creating confusion matrix based on actual response variable and predicted value.
trainData$predicted.response <- predict(pcap.env.rf.sub, trainData)

# Create Confusion Matrix
confusionMatrix(data=trainData$predicted.response,
                reference=trainData$pcap.forests.forest_group,
                positive='yes')


#validation (test) data
# Predicting response variable
testData$predicted.response <- predict(pcap.env.rf.sub, testData)

# Create Confusion Matrix
confusionMatrix(data=testData$predicted.response,
                reference=testData$pcap.forests.forest_group,
                positive='yes')



##try randomForest for niche modelling (i.e., species habitat modeling)

ind <- sample(2,nrow(pcap.forests[,2:192]),replace=TRUE,prob=c(0.7,0.3))
trainData <- pcap.forests[,2:192][ind==1,]
trainData
testData <- pcap.forests[,2:192][ind==2,]

pcap.rf2 <- randomForest(as.factor(forest_group)~ ., data=trainData,ntree=10000, Importance = TRUE, proximity=TRUE)
pcap.rf2
plot(pcap.rf2)
table(predict(pcap.rf2),trainData$forest_group)
print(pcap.rf2)

Prediction <- predict(pcap.rf2, testData)
Prediction
submit <- data.frame(plot_id = testData$plot_id, Survived = Prediction) #error because plot_id not in data frame
#write.csv(submit, file = "firstforest_pcap_env_test.csv", row.names = FALSE)

#plot variable importance
varImpPlot(pcap.rf2)

### consider trying analyses without alluvial plots to see if things improve at all ####


### try PERMANOVA #####

pcap.grp.adonis <- adonis(pcap.forests[,2:192] ~ pcap.forests$forest_group)
pcap.grp.adonis
